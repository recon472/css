{"version":3,"sources":["webpack:///./src/html.js","webpack:///./node_modules/xml-parser-xo/index.js","webpack:///./src/views/Breadcrumb.vue?2fba","webpack:///src/views/Breadcrumb.vue","webpack:///./src/views/Breadcrumb.vue?e434","webpack:///./src/views/Breadcrumb.vue","webpack:///./node_modules/xml-formatter/index.js"],"names":["format","require","module","exports","object","reference","html","$refs","innerHTML","toString","collapseContent","parse","xml","options","nextChild","tag","content","comment","cdata","nextRootChild","match","doctype","processingInstruction","document","decl","declaration","children","documentRootNode","child","node","type","Error","excluded","push","root","matchDeclaration","m","name","attributes","eos","is","attr","attribute","value","filter","matchRoot","strip","val","replace","re","slice","length","prefix","indexOf","trim","render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","ref","_m","attrs","_s","code1","staticRenderFns","data","mounted","component","newLine","state","i","lineSeparator","level","indentation","appendContent","processNode","preserveSpace","processContentNode","processElementNode","processProcessingIntruction","processAttributes","selfClosingNodeClosingTag","whiteSpaceAtEndOfSelfclosingTag","nodePreserveSpace","containsTextNodes","some","forEach","Object","keys","escaped","parser","parsedXml"],"mappings":"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","file":"js/chunk-7edf1c4f.1eaa715a.js","sourcesContent":["const format = require(\"xml-formatter\");\r\n\r\nmodule.exports = (object, reference) => {\r\n    const html = object.$refs[reference].innerHTML.toString();\r\n    return format(\"<root>\" + html + \"</root>\", {\r\n        collapseContent: true,\r\n    });\r\n}","/**\n * @typedef {Object} ParsingOptions\n *  @property {function(node)} filter Returns false to exclude a node. Default is true.\n */\n\n/**\n * Parse the given XML string into an object.\n *\n * @param {String} xml\n * @param {ParsingOptions} [options]\n * @return {Object}\n * @api public\n */\nfunction parse(xml, options = {}) {\n\n    options.filter = options.filter || (() => true);\n\n    function nextChild() {\n        return tag() || content() || comment() || cdata();\n    }\n\n    function nextRootChild() {\n        match(/\\s*/);\n        return tag(true) || comment() || doctype() || processingInstruction(false);\n    }\n\n    function document() {\n        const decl = declaration();\n        const children = [];\n        let documentRootNode;\n        let child = nextRootChild();\n\n        while (child) {\n            if (child.node.type === 'Element') {\n                if (documentRootNode) {\n                    throw new Error('Found multiple root nodes');\n                }\n                documentRootNode = child.node;\n            }\n\n            if (!child.excluded) {\n                children.push(child.node);\n            }\n\n            child = nextRootChild();\n        }\n\n        if (!documentRootNode) {\n            throw new Error('Failed to parse XML');\n        }\n\n        return {\n            declaration: decl ? decl.node : null,\n            root: documentRootNode,\n            children\n        };\n    }\n\n    function declaration() {\n        return processingInstruction(true);\n    }\n\n    function processingInstruction(matchDeclaration) {\n        const m = matchDeclaration ? match(/^<\\?(xml)\\s*/) : match(/^<\\?([\\w-:.]+)\\s*/);\n        if (!m) return;\n\n        // tag\n        const node = {\n            name: m[1],\n            type: 'ProcessingInstruction',\n            attributes: {}\n        };\n\n        // attributes\n        while (!(eos() || is('?>'))) {\n            const attr = attribute();\n            if (!attr) return node;\n            node.attributes[attr.name] = attr.value;\n        }\n\n        match(/\\?>/);\n\n        return {\n            excluded: matchDeclaration ? false : options.filter(node) === false,\n            node\n        };\n    }\n\n    function tag(matchRoot) {\n        const m = match(/^<([\\w-:.]+)\\s*/);\n        if (!m) return;\n\n        // name\n        const node = {\n            type: 'Element',\n            name: m[1],\n            attributes: {},\n            children: []\n        };\n\n        // attributes\n        while (!(eos() || is('>') || is('?>') || is('/>'))) {\n            const attr = attribute();\n            if (!attr) return node;\n            node.attributes[attr.name] = attr.value;\n        }\n\n        const excluded = matchRoot ? false : options.filter(node) === false;\n\n        // self closing tag\n        if (match(/^\\s*\\/>/)) {\n            node.children = null;\n            return {\n                excluded,\n                node\n            };\n        }\n\n        match(/\\??>/);\n\n        if (!excluded) {\n            // children\n            let child = nextChild();\n            while (child) {\n                if (!child.excluded) {\n                    node.children.push(child.node);\n                }\n                child = nextChild();\n            }\n        }\n\n        // closing\n        match(/^<\\/[\\w-:.]+>/);\n\n        return {\n            excluded,\n            node\n        };\n    }\n\n    function doctype() {\n        const m = match(/^<!DOCTYPE\\s+[^>]*>/);\n        if (m) {\n            const node = {\n                type: 'DocumentType',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function cdata() {\n        const m = match(/^<!\\[CDATA\\[[^\\]\\]>]*]]>/);\n        if (m) {\n            const node = {\n                type: 'CDATA',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function comment() {\n        const m = match(/^<!--[\\s\\S]*?-->/);\n        if (m) {\n            const node = {\n                type: 'Comment',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function content() {\n        const m = match(/^([^<]+)/);\n        if (m) {\n            const node = {\n                type: 'Text',\n                content: m[1]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function attribute() {\n        const m = match(/([\\w:-]+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|\\w+)\\s*/);\n        if (!m) return;\n        return {name: m[1], value: strip(m[2])}\n    }\n\n    /**\n     * Strip quotes from `val`.\n     */\n    function strip(val) {\n        return val.replace(/^['\"]|['\"]$/g, '');\n    }\n\n    /**\n     * Match `re` and advance the string.\n     */\n    function match(re) {\n        const m = xml.match(re);\n        if (!m) return;\n        xml = xml.slice(m[0].length);\n        return m;\n    }\n\n    /**\n     * End-of-source.\n     */\n    function eos() {\n        return 0 === xml.length;\n    }\n\n    /**\n     * Check for `prefix`.\n     */\n    function is(prefix) {\n        return 0 === xml.indexOf(prefix);\n    }\n\n    xml = xml.trim();\n\n    return document();\n}\n\nmodule.exports = parse;\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"v-stack h-stretch\"},[_c('h6',{staticClass:\"text-left\"},[_vm._v(\"Breadcrumb\")]),_c('div',{staticClass:\"card border light\"},[_c('div',{ref:\"code1\",staticClass:\"content\"},[_vm._m(0)])]),_c('prism',{attrs:{\"language\":\"html\"}},[_vm._v(_vm._s(_vm.code1))])],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"breadcrumb\"},[_c('div',[_vm._v(\"Home\")]),_c('div',[_vm._v(\"Products\")]),_c('div',[_vm._v(\"Devices\")]),_c('div',{staticClass:\"disabled\"},[_vm._v(\"Phones\")])])}]\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"v-stack h-stretch\">\r\n    <h6 class=\"text-left\">Breadcrumb</h6>\r\n    <div class=\"card border light\">\r\n      <div ref=\"code1\" class=\"content\">\r\n        <div class=\"breadcrumb\">\r\n          <div>Home</div>\r\n          <div>Products</div>\r\n          <div>Devices</div>\r\n          <div class=\"disabled\">Phones</div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <prism language=\"html\">{{ code1 }}</prism>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nconst html = require(\"@/html.js\");\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      code1: \"\",\r\n    };\r\n  },\r\n  mounted() {\r\n    this.code1 = html(this, \"code1\");\r\n  },\r\n};\r\n</script>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Breadcrumb.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Breadcrumb.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Breadcrumb.vue?vue&type=template&id=e1fbfd46&\"\nimport script from \"./Breadcrumb.vue?vue&type=script&lang=js&\"\nexport * from \"./Breadcrumb.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","/**\n * @typedef {Object} XMLFormatterOptions\n *  @property {String} [indentation='    '] The value used for indentation\n *  @property {function(node): boolean} [filter] Return false to exclude the node.\n *  @property {Boolean} [collapseContent=false] True to keep content in the same line as the element. Only works if element contains at least one text node\n *  @property {String} [lineSeparator='\\r\\n'] The line separator to use\n *  @property {String} [whiteSpaceAtEndOfSelfclosingTag=false] to either end ad self closing tag with `<tag/>` or `<tag />`\n */\n\n/**\n * @typedef {Object} XMLFormatterState\n * @param {String} content\n * @param {Number} level\n * @param {XMLFormatterOptions} options\n */\n\n/**\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction newLine(state) {\n    state.content += state.options.lineSeparator;\n    let i;\n    for (i = 0; i < state.level; i++) {\n        state.content += state.options.indentation;\n    }\n}\n\n/**\n * @param {XMLFormatterState} state\n * @param {String} content\n * @return {void}\n */\nfunction appendContent(state, content) {\n    state.content += content;\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processNode(node, state, preserveSpace) {\n    if (typeof node.content === 'string') {\n        processContentNode(node, state, preserveSpace);\n    } else if (node.type === 'Element') {\n        processElementNode(node, state, preserveSpace);\n    } else if (node.type === 'ProcessingInstruction') {\n        processProcessingIntruction(node, state, preserveSpace);\n    } else {\n        throw new Error('Unknown node type: ' + node.type);\n    }\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processContentNode(node, state, preserveSpace) {\n    if (!preserveSpace) {\n        node.content = node.content.trim();\n    }\n    if (node.content.length > 0) {\n        if (!preserveSpace && state.content.length > 0) {\n            newLine(state);\n        }\n        appendContent(state, node.content);\n    }\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processElementNode(node, state, preserveSpace) {\n    if (!preserveSpace && state.content.length > 0) {\n        newLine(state);\n    }\n\n    appendContent(state, '<' + node.name);\n    processAttributes(state, node.attributes);\n\n    if (node.children === null) {\n        const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? ' />' : '/>'\n        // self-closing node\n        appendContent(state, selfClosingNodeClosingTag);\n    } else if (node.children.length === 0) {\n        // empty node\n        appendContent(state, '></' + node.name + '>');\n    } else {\n\n        appendContent(state, '>');\n\n        state.level++;\n\n        let nodePreserveSpace = node.attributes['xml:space'] === 'preserve';\n\n        if (!nodePreserveSpace && state.options.collapseContent) {\n\n            const containsTextNodes = node.children.some(function(child) {\n                return child.type === 'Text' && child.content.trim() !== '';\n            });\n\n            if (containsTextNodes) {\n                nodePreserveSpace = true;\n            }\n        }\n\n        node.children.forEach(function(child) {\n            processNode(child, state, preserveSpace || nodePreserveSpace, state.options);\n        });\n\n        state.level--;\n\n        if (!preserveSpace && !nodePreserveSpace) {\n            newLine(state);\n        }\n        appendContent(state, '</' + node.name + '>');\n    }\n}\n\n/**\n * @param {XMLFormatterState} state\n * @param {Record<String, String>} attributes\n * @return {void}\n */\nfunction processAttributes(state, attributes) {\n    Object.keys(attributes).forEach(function(attr) {\n        const escaped = attributes[attr].replace(/\"/g, '&quot;');\n        appendContent(state, ' ' + attr + '=\"' + escaped + '\"');\n    });\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction processProcessingIntruction(node, state) {\n    if (state.content.length > 0) {\n        newLine(state);\n    }\n    appendContent(state, '<?' + node.name);\n    processAttributes(state, node.attributes);\n    appendContent(state, '?>');\n}\n\n\n/**\n * Converts the given XML into human readable format.\n *\n * @param {String} xml\n * @param {XMLFormatterOptions} options\n * @returns {string}\n */\nfunction format(xml, options = {}) {\n    options.indentation = options.indentation || '    ';\n    options.collapseContent = options.collapseContent === true;\n    options.lineSeparator = options.lineSeparator || '\\r\\n';\n    options.whiteSpaceAtEndOfSelfclosingTag = !!options.whiteSpaceAtEndOfSelfclosingTag;\n\n    const parser = require('xml-parser-xo');\n    const parsedXml = parser(xml, {filter: options.filter});\n    const state = {content: '', level: 0, options: options};\n\n    if (parsedXml.declaration) {\n        processProcessingIntruction(parsedXml.declaration, state);\n    }\n\n    parsedXml.children.forEach(function(child) {\n        processNode(child, state, false);\n    });\n\n    return state.content;\n}\n\n\nmodule.exports = format;\n"],"sourceRoot":""}