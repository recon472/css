{"version":3,"sources":["webpack:///./node_modules/xml-parser-xo/index.js","webpack:///./src/views/Button.vue?85fc","webpack:///src/views/Button.vue","webpack:///./src/views/Button.vue?e6da","webpack:///./src/views/Button.vue","webpack:///./node_modules/xml-formatter/index.js"],"names":["parse","xml","options","nextChild","tag","content","comment","cdata","nextRootChild","match","doctype","processingInstruction","document","decl","declaration","children","documentRootNode","child","node","type","Error","excluded","push","root","matchDeclaration","m","name","attributes","eos","is","attr","attribute","value","filter","matchRoot","strip","val","replace","re","slice","length","prefix","indexOf","trim","module","exports","render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","ref","_m","attrs","_s","code1","code2","code3","staticRenderFns","format","data","methods","htmlToString","$refs","reference","innerHTML","toString","mounted","collapseContent","component","newLine","state","i","lineSeparator","level","indentation","appendContent","processNode","preserveSpace","processContentNode","processElementNode","processProcessingIntruction","processAttributes","selfClosingNodeClosingTag","whiteSpaceAtEndOfSelfclosingTag","nodePreserveSpace","containsTextNodes","some","forEach","Object","keys","escaped","parser","parsedXml"],"mappings":"iGAaA,SAASA,EAAMC,EAAKC,EAAU,IAI1B,SAASC,IACL,OAAOC,KAASC,KAAaC,KAAaC,IAG9C,SAASC,IAEL,OADAC,EAAM,OACCL,GAAI,IAASE,KAAaI,KAAaC,GAAsB,GAGxE,SAASC,IACL,MAAMC,EAAOC,IACPC,EAAW,GACjB,IAAIC,EACAC,EAAQT,IAEZ,MAAOS,EAAO,CACV,GAAwB,YAApBA,EAAMC,KAAKC,KAAoB,CAC/B,GAAIH,EACA,MAAM,IAAII,MAAM,6BAEpBJ,EAAmBC,EAAMC,KAGxBD,EAAMI,UACPN,EAASO,KAAKL,EAAMC,MAGxBD,EAAQT,IAGZ,IAAKQ,EACD,MAAM,IAAII,MAAM,uBAGpB,MAAO,CACHN,YAAaD,EAAOA,EAAKK,KAAO,KAChCK,KAAMP,EACND,YAIR,SAASD,IACL,OAAOH,GAAsB,GAGjC,SAASA,EAAsBa,GAC3B,MAAMC,EAAuBhB,EAAnBe,EAAyB,eAAwB,qBAC3D,IAAKC,EAAG,OAGR,MAAMP,EAAO,CACTQ,KAAMD,EAAE,GACRN,KAAM,wBACNQ,WAAY,IAIhB,OAASC,MAASC,EAAG,MAAQ,CACzB,MAAMC,EAAOC,IACb,IAAKD,EAAM,OAAOZ,EAClBA,EAAKS,WAAWG,EAAKJ,MAAQI,EAAKE,MAKtC,OAFAvB,EAAM,OAEC,CACHY,UAAUG,IAAoD,IAAzBtB,EAAQ+B,OAAOf,GACpDA,QAIR,SAASd,EAAI8B,GACT,MAAMT,EAAIhB,EAAM,mBAChB,IAAKgB,EAAG,OAGR,MAAMP,EAAO,CACTC,KAAM,UACNO,KAAMD,EAAE,GACRE,WAAY,GACZZ,SAAU,IAId,QAASa,KAASC,EAAG,MAAQA,EAAG,OAASA,EAAG,OAAQ,CAChD,MAAMC,EAAOC,IACb,IAAKD,EAAM,OAAOZ,EAClBA,EAAKS,WAAWG,EAAKJ,MAAQI,EAAKE,MAGtC,MAAMX,GAAWa,IAA6C,IAAzBhC,EAAQ+B,OAAOf,GAGpD,GAAIT,EAAM,WAEN,OADAS,EAAKH,SAAW,KACT,CACHM,WACAH,QAMR,GAFAT,EAAM,SAEDY,EAAU,CAEX,IAAIJ,EAAQd,IACZ,MAAOc,EACEA,EAAMI,UACPH,EAAKH,SAASO,KAAKL,EAAMC,MAE7BD,EAAQd,IAOhB,OAFAM,EAAM,iBAEC,CACHY,WACAH,QAIR,SAASR,IACL,MAAMe,EAAIhB,EAAM,uBAChB,GAAIgB,EAAG,CACH,MAAMP,EAAO,CACTC,KAAM,eACNd,QAASoB,EAAE,IAEf,MAAO,CACHJ,UAAmC,IAAzBnB,EAAQ+B,OAAOf,GACzBA,SAKZ,SAASX,IACL,MAAMkB,EAAIhB,EAAM,4BAChB,GAAIgB,EAAG,CACH,MAAMP,EAAO,CACTC,KAAM,QACNd,QAASoB,EAAE,IAEf,MAAO,CACHJ,UAAmC,IAAzBnB,EAAQ+B,OAAOf,GACzBA,SAKZ,SAASZ,IACL,MAAMmB,EAAIhB,EAAM,oBAChB,GAAIgB,EAAG,CACH,MAAMP,EAAO,CACTC,KAAM,UACNd,QAASoB,EAAE,IAEf,MAAO,CACHJ,UAAmC,IAAzBnB,EAAQ+B,OAAOf,GACzBA,SAKZ,SAASb,IACL,MAAMoB,EAAIhB,EAAM,YAChB,GAAIgB,EAAG,CACH,MAAMP,EAAO,CACTC,KAAM,OACNd,QAASoB,EAAE,IAEf,MAAO,CACHJ,UAAmC,IAAzBnB,EAAQ+B,OAAOf,GACzBA,SAKZ,SAASa,IACL,MAAMN,EAAIhB,EAAM,4CAChB,GAAKgB,EACL,MAAO,CAACC,KAAMD,EAAE,GAAIO,MAAOG,EAAMV,EAAE,KAMvC,SAASU,EAAMC,GACX,OAAOA,EAAIC,QAAQ,eAAgB,IAMvC,SAAS5B,EAAM6B,GACX,MAAMb,EAAIxB,EAAIQ,MAAM6B,GACpB,GAAKb,EAEL,OADAxB,EAAMA,EAAIsC,MAAMd,EAAE,GAAGe,QACdf,EAMX,SAASG,IACL,OAAO,IAAM3B,EAAIuC,OAMrB,SAASX,EAAGY,GACR,OAAO,IAAMxC,EAAIyC,QAAQD,GAK7B,OA5NAvC,EAAQ+B,OAAS/B,EAAQ+B,QAAU,MAAO,GA0N1ChC,EAAMA,EAAI0C,OAEH/B,IAGXgC,EAAOC,QAAU7C,G,2CC9OjB,IAAI8C,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,WAAW,CAACF,EAAG,KAAK,CAACE,YAAY,aAAa,CAACN,EAAIO,GAAG,YAAYH,EAAG,MAAM,CAACE,YAAY,qBAAqB,CAACF,EAAG,MAAM,CAACE,YAAY,WAAW,CAACF,EAAG,MAAM,CAACI,IAAI,QAAQF,YAAY,iBAAiB,CAACF,EAAG,SAAS,CAACJ,EAAIO,GAAG,YAAYH,EAAG,SAAS,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,UAAUH,EAAG,SAAS,CAACE,YAAY,WAAW,CAACN,EAAIO,GAAG,kBAAkBP,EAAIS,GAAG,GAAGL,EAAG,SAAS,CAACE,YAAY,UAAU,CAACN,EAAIO,GAAG,YAAYH,EAAG,SAAS,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,gBAAgBH,EAAG,QAAQ,CAACM,MAAM,CAAC,SAAW,SAAS,CAACV,EAAIO,GAAGP,EAAIW,GAAGX,EAAIY,UAAUR,EAAG,MAAM,CAACE,YAAY,qBAAqB,CAACF,EAAG,MAAM,CAACE,YAAY,WAAW,CAACF,EAAG,MAAM,CAACI,IAAI,QAAQF,YAAY,iBAAiB,CAACF,EAAG,SAAS,CAACE,YAAY,WAAW,CAACN,EAAIO,GAAG,aAAaH,EAAG,SAAS,CAACE,YAAY,aAAa,CAACN,EAAIO,GAAG,eAAeH,EAAG,SAAS,CAACE,YAAY,WAAW,CAACN,EAAIO,GAAG,aAAaH,EAAG,SAAS,CAACE,YAAY,SAAS,CAACN,EAAIO,GAAG,iBAAiBH,EAAG,QAAQ,CAACM,MAAM,CAAC,SAAW,SAAS,CAACV,EAAIO,GAAGP,EAAIW,GAAGX,EAAIa,UAAUT,EAAG,MAAM,CAACE,YAAY,qBAAqB,CAACF,EAAG,MAAM,CAACE,YAAY,WAAW,CAACF,EAAG,MAAM,CAACI,IAAI,QAAQF,YAAY,iBAAiB,CAACF,EAAG,SAAS,CAACE,YAAY,SAAS,CAACN,EAAIO,GAAG,WAAWH,EAAG,SAAS,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,gBAAgBH,EAAG,QAAQ,CAACM,MAAM,CAAC,SAAW,SAAS,CAACV,EAAIO,GAAGP,EAAIW,GAAGX,EAAIc,WAAW,IAC12CC,EAAkB,CAAC,WAAa,IAAIf,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,SAAS,CAACE,YAAY,QAAQ,CAACF,EAAG,IAAI,CAACE,YAAY,qBCyC5JU,G,oBAAS,EAAb,SAEA,GACEC,KADF,WAEI,MAAO,CACLL,MAAO,GACPC,MAAO,GACPC,MAAO,KAGXI,QAAS,CACPC,aADJ,SACA,GACM,OAAOlB,KAAKmB,MAAMC,GAAWC,UAAUC,aAG3CC,QAbF,WAcIvB,KAAKW,MAAQI,EAAO,SAAWf,KAAKkB,aAAa,SAAW,UAAW,CACrEM,iBAAiB,IAEnBxB,KAAKY,MAAQG,EAAO,SAAWf,KAAKkB,aAAa,SAAW,UAAW,CACrEM,iBAAiB,IAEnBxB,KAAKa,MAAQE,EAAO,SAAWf,KAAKkB,aAAa,SAAW,UAAW,CACrEM,iBAAiB,MCjEyT,I,YCO5UC,EAAY,eACd,EACA3B,EACAgB,GACA,EACA,KACA,KACA,MAIa,aAAAW,E,8BCEf,SAASC,EAAQC,GAEb,IAAIC,EACJ,IAFAD,EAAMtE,SAAWsE,EAAMzE,QAAQ2E,cAE1BD,EAAI,EAAGA,EAAID,EAAMG,MAAOF,IACzBD,EAAMtE,SAAWsE,EAAMzE,QAAQ6E,YASvC,SAASC,EAAcL,EAAOtE,GAC1BsE,EAAMtE,SAAWA,EASrB,SAAS4E,EAAY/D,EAAMyD,EAAOO,GAC9B,GAA4B,kBAAjBhE,EAAKb,QACZ8E,EAAmBjE,EAAMyD,EAAOO,QAC7B,GAAkB,YAAdhE,EAAKC,KACZiE,EAAmBlE,EAAMyD,EAAOO,OAC7B,IAAkB,0BAAdhE,EAAKC,KAGZ,MAAM,IAAIC,MAAM,sBAAwBF,EAAKC,MAF7CkE,EAA4BnE,EAAMyD,EAAOO,IAYjD,SAASC,EAAmBjE,EAAMyD,EAAOO,GAChCA,IACDhE,EAAKb,QAAUa,EAAKb,QAAQsC,QAE5BzB,EAAKb,QAAQmC,OAAS,KACjB0C,GAAiBP,EAAMtE,QAAQmC,OAAS,GACzCkC,EAAQC,GAEZK,EAAcL,EAAOzD,EAAKb,UAUlC,SAAS+E,EAAmBlE,EAAMyD,EAAOO,GAQrC,IAPKA,GAAiBP,EAAMtE,QAAQmC,OAAS,GACzCkC,EAAQC,GAGZK,EAAcL,EAAO,IAAMzD,EAAKQ,MAChC4D,EAAkBX,EAAOzD,EAAKS,YAER,OAAlBT,EAAKH,SAAmB,CACxB,MAAMwE,EAA4BZ,EAAMzE,QAAQsF,gCAAkC,MAAQ,KAE1FR,EAAcL,EAAOY,QAClB,GAA6B,IAAzBrE,EAAKH,SAASyB,OAErBwC,EAAcL,EAAO,MAAQzD,EAAKQ,KAAO,SACtC,CAEHsD,EAAcL,EAAO,KAErBA,EAAMG,QAEN,IAAIW,EAAqD,aAAjCvE,EAAKS,WAAW,aAExC,IAAK8D,GAAqBd,EAAMzE,QAAQsE,gBAAiB,CAErD,MAAMkB,EAAoBxE,EAAKH,SAAS4E,MAAK,SAAS1E,GAClD,MAAsB,SAAfA,EAAME,MAA4C,KAAzBF,EAAMZ,QAAQsC,UAG9C+C,IACAD,GAAoB,GAI5BvE,EAAKH,SAAS6E,SAAQ,SAAS3E,GAC3BgE,EAAYhE,EAAO0D,EAAOO,GAAiBO,EAAmBd,EAAMzE,YAGxEyE,EAAMG,QAEDI,GAAkBO,GACnBf,EAAQC,GAEZK,EAAcL,EAAO,KAAOzD,EAAKQ,KAAO,MAShD,SAAS4D,EAAkBX,EAAOhD,GAC9BkE,OAAOC,KAAKnE,GAAYiE,SAAQ,SAAS9D,GACrC,MAAMiE,EAAUpE,EAAWG,GAAMO,QAAQ,KAAM,UAC/C2C,EAAcL,EAAO,IAAM7C,EAAO,KAAOiE,EAAU,QAS3D,SAASV,EAA4BnE,EAAMyD,GACnCA,EAAMtE,QAAQmC,OAAS,GACvBkC,EAAQC,GAEZK,EAAcL,EAAO,KAAOzD,EAAKQ,MACjC4D,EAAkBX,EAAOzD,EAAKS,YAC9BqD,EAAcL,EAAO,MAWzB,SAASZ,EAAO9D,EAAKC,EAAU,IAC3BA,EAAQ6E,YAAc7E,EAAQ6E,aAAe,OAC7C7E,EAAQsE,iBAA8C,IAA5BtE,EAAQsE,gBAClCtE,EAAQ2E,cAAgB3E,EAAQ2E,eAAiB,OACjD3E,EAAQsF,kCAAoCtF,EAAQsF,gCAEpD,MAAMQ,EAAS,EAAQ,QACjBC,EAAYD,EAAO/F,EAAK,CAACgC,OAAQ/B,EAAQ+B,SACzC0C,EAAQ,CAACtE,QAAS,GAAIyE,MAAO,EAAG5E,QAASA,GAU/C,OARI+F,EAAUnF,aACVuE,EAA4BY,EAAUnF,YAAa6D,GAGvDsB,EAAUlF,SAAS6E,SAAQ,SAAS3E,GAChCgE,EAAYhE,EAAO0D,GAAO,MAGvBA,EAAMtE,QAIjBuC,EAAOC,QAAUkB","file":"js/chunk-0fd59bba.b6176559.js","sourcesContent":["/**\n * @typedef {Object} ParsingOptions\n *  @property {function(node)} filter Returns false to exclude a node. Default is true.\n */\n\n/**\n * Parse the given XML string into an object.\n *\n * @param {String} xml\n * @param {ParsingOptions} [options]\n * @return {Object}\n * @api public\n */\nfunction parse(xml, options = {}) {\n\n    options.filter = options.filter || (() => true);\n\n    function nextChild() {\n        return tag() || content() || comment() || cdata();\n    }\n\n    function nextRootChild() {\n        match(/\\s*/);\n        return tag(true) || comment() || doctype() || processingInstruction(false);\n    }\n\n    function document() {\n        const decl = declaration();\n        const children = [];\n        let documentRootNode;\n        let child = nextRootChild();\n\n        while (child) {\n            if (child.node.type === 'Element') {\n                if (documentRootNode) {\n                    throw new Error('Found multiple root nodes');\n                }\n                documentRootNode = child.node;\n            }\n\n            if (!child.excluded) {\n                children.push(child.node);\n            }\n\n            child = nextRootChild();\n        }\n\n        if (!documentRootNode) {\n            throw new Error('Failed to parse XML');\n        }\n\n        return {\n            declaration: decl ? decl.node : null,\n            root: documentRootNode,\n            children\n        };\n    }\n\n    function declaration() {\n        return processingInstruction(true);\n    }\n\n    function processingInstruction(matchDeclaration) {\n        const m = matchDeclaration ? match(/^<\\?(xml)\\s*/) : match(/^<\\?([\\w-:.]+)\\s*/);\n        if (!m) return;\n\n        // tag\n        const node = {\n            name: m[1],\n            type: 'ProcessingInstruction',\n            attributes: {}\n        };\n\n        // attributes\n        while (!(eos() || is('?>'))) {\n            const attr = attribute();\n            if (!attr) return node;\n            node.attributes[attr.name] = attr.value;\n        }\n\n        match(/\\?>/);\n\n        return {\n            excluded: matchDeclaration ? false : options.filter(node) === false,\n            node\n        };\n    }\n\n    function tag(matchRoot) {\n        const m = match(/^<([\\w-:.]+)\\s*/);\n        if (!m) return;\n\n        // name\n        const node = {\n            type: 'Element',\n            name: m[1],\n            attributes: {},\n            children: []\n        };\n\n        // attributes\n        while (!(eos() || is('>') || is('?>') || is('/>'))) {\n            const attr = attribute();\n            if (!attr) return node;\n            node.attributes[attr.name] = attr.value;\n        }\n\n        const excluded = matchRoot ? false : options.filter(node) === false;\n\n        // self closing tag\n        if (match(/^\\s*\\/>/)) {\n            node.children = null;\n            return {\n                excluded,\n                node\n            };\n        }\n\n        match(/\\??>/);\n\n        if (!excluded) {\n            // children\n            let child = nextChild();\n            while (child) {\n                if (!child.excluded) {\n                    node.children.push(child.node);\n                }\n                child = nextChild();\n            }\n        }\n\n        // closing\n        match(/^<\\/[\\w-:.]+>/);\n\n        return {\n            excluded,\n            node\n        };\n    }\n\n    function doctype() {\n        const m = match(/^<!DOCTYPE\\s+[^>]*>/);\n        if (m) {\n            const node = {\n                type: 'DocumentType',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function cdata() {\n        const m = match(/^<!\\[CDATA\\[[^\\]\\]>]*]]>/);\n        if (m) {\n            const node = {\n                type: 'CDATA',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function comment() {\n        const m = match(/^<!--[\\s\\S]*?-->/);\n        if (m) {\n            const node = {\n                type: 'Comment',\n                content: m[0]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function content() {\n        const m = match(/^([^<]+)/);\n        if (m) {\n            const node = {\n                type: 'Text',\n                content: m[1]\n            };\n            return {\n                excluded: options.filter(node) === false,\n                node\n            };\n        }\n    }\n\n    function attribute() {\n        const m = match(/([\\w:-]+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|\\w+)\\s*/);\n        if (!m) return;\n        return {name: m[1], value: strip(m[2])}\n    }\n\n    /**\n     * Strip quotes from `val`.\n     */\n    function strip(val) {\n        return val.replace(/^['\"]|['\"]$/g, '');\n    }\n\n    /**\n     * Match `re` and advance the string.\n     */\n    function match(re) {\n        const m = xml.match(re);\n        if (!m) return;\n        xml = xml.slice(m[0].length);\n        return m;\n    }\n\n    /**\n     * End-of-source.\n     */\n    function eos() {\n        return 0 === xml.length;\n    }\n\n    /**\n     * Check for `prefix`.\n     */\n    function is(prefix) {\n        return 0 === xml.indexOf(prefix);\n    }\n\n    xml = xml.trim();\n\n    return document();\n}\n\nmodule.exports = parse;\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"v-stack\"},[_c('h6',{staticClass:\"text-left\"},[_vm._v(\"Button\")]),_c('div',{staticClass:\"card border light\"},[_c('div',{staticClass:\"content\"},[_c('div',{ref:\"code1\",staticClass:\"h-stack gap-3\"},[_c('button',[_vm._v(\"Normal\")]),_c('button',{staticClass:\"flat\"},[_vm._v(\"Flat\")]),_c('button',{staticClass:\"dynamic\"},[_vm._v(\"Dynamic Size\")]),_vm._m(0),_c('button',{staticClass:\"circle\"},[_vm._v(\"Circle\")]),_c('button',{staticClass:\"text\"},[_vm._v(\"Text\")])])])]),_c('prism',{attrs:{\"language\":\"html\"}},[_vm._v(_vm._s(_vm.code1))]),_c('div',{staticClass:\"card border light\"},[_c('div',{staticClass:\"content\"},[_c('div',{ref:\"code2\",staticClass:\"h-stack gap-3\"},[_c('button',{staticClass:\"primary\"},[_vm._v(\"Primary\")]),_c('button',{staticClass:\"secondary\"},[_vm._v(\"Secondary\")]),_c('button',{staticClass:\"warning\"},[_vm._v(\"Warning\")]),_c('button',{staticClass:\"error\"},[_vm._v(\"Error\")])])])]),_c('prism',{attrs:{\"language\":\"html\"}},[_vm._v(_vm._s(_vm.code2))]),_c('div',{staticClass:\"card border light\"},[_c('div',{staticClass:\"content\"},[_c('div',{ref:\"code3\",staticClass:\"h-stack gap-3\"},[_c('button',{staticClass:\"light\"},[_vm._v(\"Light\")]),_c('button',{staticClass:\"dark\"},[_vm._v(\"Dark\")])])])]),_c('prism',{attrs:{\"language\":\"html\"}},[_vm._v(_vm._s(_vm.code3))])],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:\"icon\"},[_c('i',{staticClass:\"fas fa-icons\"})])}]\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"v-stack\">\r\n    <h6 class=\"text-left\">Button</h6>\r\n    <div class=\"card border light\">\r\n      <div class=\"content\">\r\n        <div ref=\"code1\" class=\"h-stack gap-3\">\r\n          <button>Normal</button>\r\n          <button class=\"flat\">Flat</button>\r\n          <button class=\"dynamic\">Dynamic Size</button>\r\n          <button class=\"icon\">\r\n            <i class=\"fas fa-icons\"></i>\r\n          </button>\r\n          <button class=\"circle\">Circle</button>\r\n          <button class=\"text\">Text</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <prism language=\"html\">{{ code1 }}</prism>\r\n    <div class=\"card border light\">\r\n      <div class=\"content\">\r\n        <div ref=\"code2\" class=\"h-stack gap-3\">\r\n          <button class=\"primary\">Primary</button>\r\n          <button class=\"secondary\">Secondary</button>\r\n          <button class=\"warning\">Warning</button>\r\n          <button class=\"error\">Error</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <prism language=\"html\">{{ code2 }}</prism>\r\n    <div class=\"card border light\">\r\n      <div class=\"content\">\r\n        <div ref=\"code3\" class=\"h-stack gap-3\">\r\n          <button class=\"light\">Light</button>\r\n          <button class=\"dark\">Dark</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <prism language=\"html\">{{ code3 }}</prism>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nvar format = require(\"xml-formatter\");\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      code1: \"\",\r\n      code2: \"\",\r\n      code3: \"\",\r\n    };\r\n  },\r\n  methods: {\r\n    htmlToString(reference) {\r\n      return this.$refs[reference].innerHTML.toString();\r\n    },\r\n  },\r\n  mounted() {\r\n    this.code1 = format(\"<root>\" + this.htmlToString(\"code1\") + \"</root>\", {\r\n      collapseContent: true,\r\n    });\r\n    this.code2 = format(\"<root>\" + this.htmlToString(\"code2\") + \"</root>\", {\r\n      collapseContent: true,\r\n    });\r\n    this.code3 = format(\"<root>\" + this.htmlToString(\"code3\") + \"</root>\", {\r\n      collapseContent: true,\r\n    });\r\n  },\r\n};\r\n</script>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Button.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Button.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Button.vue?vue&type=template&id=595220b4&\"\nimport script from \"./Button.vue?vue&type=script&lang=js&\"\nexport * from \"./Button.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","/**\n * @typedef {Object} XMLFormatterOptions\n *  @property {String} [indentation='    '] The value used for indentation\n *  @property {function(node): boolean} [filter] Return false to exclude the node.\n *  @property {Boolean} [collapseContent=false] True to keep content in the same line as the element. Only works if element contains at least one text node\n *  @property {String} [lineSeparator='\\r\\n'] The line separator to use\n *  @property {String} [whiteSpaceAtEndOfSelfclosingTag=false] to either end ad self closing tag with `<tag/>` or `<tag />`\n */\n\n/**\n * @typedef {Object} XMLFormatterState\n * @param {String} content\n * @param {Number} level\n * @param {XMLFormatterOptions} options\n */\n\n/**\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction newLine(state) {\n    state.content += state.options.lineSeparator;\n    let i;\n    for (i = 0; i < state.level; i++) {\n        state.content += state.options.indentation;\n    }\n}\n\n/**\n * @param {XMLFormatterState} state\n * @param {String} content\n * @return {void}\n */\nfunction appendContent(state, content) {\n    state.content += content;\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processNode(node, state, preserveSpace) {\n    if (typeof node.content === 'string') {\n        processContentNode(node, state, preserveSpace);\n    } else if (node.type === 'Element') {\n        processElementNode(node, state, preserveSpace);\n    } else if (node.type === 'ProcessingInstruction') {\n        processProcessingIntruction(node, state, preserveSpace);\n    } else {\n        throw new Error('Unknown node type: ' + node.type);\n    }\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processContentNode(node, state, preserveSpace) {\n    if (!preserveSpace) {\n        node.content = node.content.trim();\n    }\n    if (node.content.length > 0) {\n        if (!preserveSpace && state.content.length > 0) {\n            newLine(state);\n        }\n        appendContent(state, node.content);\n    }\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @param {Boolean} preserveSpace\n * @return {void}\n */\nfunction processElementNode(node, state, preserveSpace) {\n    if (!preserveSpace && state.content.length > 0) {\n        newLine(state);\n    }\n\n    appendContent(state, '<' + node.name);\n    processAttributes(state, node.attributes);\n\n    if (node.children === null) {\n        const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? ' />' : '/>'\n        // self-closing node\n        appendContent(state, selfClosingNodeClosingTag);\n    } else if (node.children.length === 0) {\n        // empty node\n        appendContent(state, '></' + node.name + '>');\n    } else {\n\n        appendContent(state, '>');\n\n        state.level++;\n\n        let nodePreserveSpace = node.attributes['xml:space'] === 'preserve';\n\n        if (!nodePreserveSpace && state.options.collapseContent) {\n\n            const containsTextNodes = node.children.some(function(child) {\n                return child.type === 'Text' && child.content.trim() !== '';\n            });\n\n            if (containsTextNodes) {\n                nodePreserveSpace = true;\n            }\n        }\n\n        node.children.forEach(function(child) {\n            processNode(child, state, preserveSpace || nodePreserveSpace, state.options);\n        });\n\n        state.level--;\n\n        if (!preserveSpace && !nodePreserveSpace) {\n            newLine(state);\n        }\n        appendContent(state, '</' + node.name + '>');\n    }\n}\n\n/**\n * @param {XMLFormatterState} state\n * @param {Record<String, String>} attributes\n * @return {void}\n */\nfunction processAttributes(state, attributes) {\n    Object.keys(attributes).forEach(function(attr) {\n        const escaped = attributes[attr].replace(/\"/g, '&quot;');\n        appendContent(state, ' ' + attr + '=\"' + escaped + '\"');\n    });\n}\n\n/**\n * @param {Object} node\n * @param {XMLFormatterState} state\n * @return {void}\n */\nfunction processProcessingIntruction(node, state) {\n    if (state.content.length > 0) {\n        newLine(state);\n    }\n    appendContent(state, '<?' + node.name);\n    processAttributes(state, node.attributes);\n    appendContent(state, '?>');\n}\n\n\n/**\n * Converts the given XML into human readable format.\n *\n * @param {String} xml\n * @param {XMLFormatterOptions} options\n * @returns {string}\n */\nfunction format(xml, options = {}) {\n    options.indentation = options.indentation || '    ';\n    options.collapseContent = options.collapseContent === true;\n    options.lineSeparator = options.lineSeparator || '\\r\\n';\n    options.whiteSpaceAtEndOfSelfclosingTag = !!options.whiteSpaceAtEndOfSelfclosingTag;\n\n    const parser = require('xml-parser-xo');\n    const parsedXml = parser(xml, {filter: options.filter});\n    const state = {content: '', level: 0, options: options};\n\n    if (parsedXml.declaration) {\n        processProcessingIntruction(parsedXml.declaration, state);\n    }\n\n    parsedXml.children.forEach(function(child) {\n        processNode(child, state, false);\n    });\n\n    return state.content;\n}\n\n\nmodule.exports = format;\n"],"sourceRoot":""}